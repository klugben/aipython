太好了，我们就按“导师 + 实操落地”的方式来搞定你这套 AI 编程流程，并把可下载文件都给你。

# 一、先评价你朋友给的工作流（哪里好、哪里会踩坑）

**你朋友的流程**：需求 → AI 生成 README → AI 生 PRD → AI 生后端文档 → 完成后端代码 → AI 生 API 文档 → AI 生前端文档 → 完成前端代码 → 修 bug → 跑通 demo → 再迭代。

**优点**

* 有“文档驱动开发”的意识（README/PRD/API 文档 → 代码）。
* 前后端分层清晰，能让 AI 各阶段发挥作用。
* 先出一个“能跑”的 demo，再扩展功能，符合增量式交付。

**需要改进的关键点**

1. **缺少“可行性 Spike”和“最小可演示增量（MDI）”**：
   现实里很多时间会卡在“数据源/权限/限频/库兼容”上。先用 Spike 验证最难/最不确定的一点，再进入大规模生成。每次只做一个 MDI，把“能演示”作为合格线。
2. **没有“契约先行（Contract-first）”**：
   API、数据结构与边界条件应先写成契约（OpenAPI/JSON Schema），再让 AI 按契约出桩代码 + 契约测试，能把后续很多回归问题挡在门外。
3. **无“质量门禁与回滚”**：
   没有 lint/type/test/contract 的门禁，很容易后面“无限修 bug”。把“自动化检查全绿”作为合并前置条件，并保留 Feature Flag + 一键回滚。
4. **缺少“可观测性（日志/指标/告警）”**：
   这是 AI 代码特别容易忽略的部分，但它决定了你后续定位问题的效率。
5. **“先读库、写 TODO、确认计划”的习惯需要强制化**：
   你之前强调的“先写 TODO 并勾选”是对的，要把它做成阻断式规则（不写计划不许改代码）。

> 结论：把“Spike + MDI + 契约先行 + 门禁 + 可观测”植入整个链路，你的效率和可控性会大幅提升。

---

# 二、给你一套“对标最佳实践”的改进版工作流（简版总览）

1. **A. 对齐目标**：一页纸问题陈述 + SLO/OKR → **Spike 验证最大不确定性**。
2. **B. 文档即代码**：README 草案 → PRD → ADR → **API 契约（OpenAPI/Schema）**。
3. **C. 实现（循环）**：选择一个 **MDI** → 写测试/契约 → 实现 → `lint+type+test` → 文档同步。
4. **D. 可观测与发布**：日志/指标/告警到位 → 打 Tag/灰度 → 回滚预案。
5. **E. 复盘**：每个里程碑 30 分钟，总结行动项写回 `TODO.md`。

与你的习惯强绑定的硬规则：

* “首先认真阅读仓库与文档 → 在 `TODO.md` 写计划/清单 → **先确认再开工** → 完成一项勾一项 → 每步说明改动与原因。”

---

# 三、已结合你现有 V3 文档，输出了 V4 全量文件（可下载）

我读取了你上传的三份 V3 文件（若有缺页就按最佳实践补齐），在此基础上做了结构化升级，新增了 Spike/MDI、契约先行、门禁、可观测、ADR 等模块，并把你“TODO 勾选 + 先确认”的要求写成硬性门禁。

**下载链接（点即可下载）：**

* [Global\_rules\_V4.md](sandbox:/mnt/data/Global_rules_V4.md)
* [Python\_rules\_V4.md](sandbox:/mnt/data/Python_rules_V4.md)
* [Workflow\_V4.md](sandbox:/mnt/data/Workflow_V4.md)

（注：我已对你现有 V3 做了兼容合并；V3 的简要预览我也看过并对齐了风格。）

---

# 四、基于你的目标（Python + AkShare 监控 + 触发小程序提醒 + 查询网页）

我为这个**具体项目**额外生成了“工作空间专用”的规则与工作流，还顺手给你配了 README、PRD 草案、API 契约草案和一个配置示例，直接能开干：

**工作空间专用文档**

* [workspace\_rules\_akshare.md](sandbox:/mnt/data/workspace_rules_akshare.md)
  目录结构、配置规范、速率限制、触发规则 DSL、存储与可观测约束都写好了。
* [workspace\_workflow\_akshare.md](sandbox:/mnt/data/workspace_workflow_akshare.md)
  按 **MDI#1 → #5** 逐步打通：命令行→定时→通知→网页→小程序/企业微信。

**开箱资料（可直接用作仓库起步）**

* [README\_AkMon.md](sandbox:/mnt/data/README_AkMon.md)
* [PRD\_AkMon.md](sandbox:/mnt/data/PRD_AkMon.md)
* [API\_AkMon.md](sandbox:/mnt/data/API_AkMon.md)
* 配置示例：[configs/app.example.yaml](sandbox:/mnt/data/configs_app.example.yaml)

> 这些文件里我已经把你关心的“IC 贴水率阈值触发提醒”“股票短时跌幅触发”等规则写成了示例；通知通道用**企业微信机器人 Webhook**先打通，方便上手，后续可扩展 Server 酱/飞书/短信。

---

# 五、如何在 Cursor + Cline + GLM4.5 下落地（速用清单）

1. **把以上文件放入新仓库**，按建议目录组织（`docs/`, `src/`, `configs/`, `tests/`…）。
2. **在 Cline 的系统规则里粘贴《Global\_rules\_V4.md》的“强制习惯”段**，并添加：

   * “先读 `README_AkMon.md`、`PRD_AkMon.md`、`API_AkMon.md`、`workspace_rules_akshare.md`、`workspace_workflow_akshare.md`、`/src` 目录，再写 `TODO.md` 并输出执行计划，未确认不准修改代码。”
3. **第一轮让 AI 只做 MDI#1**：

   * 生成 `src/akmon/app.py` 骨架（读取配置 → 调 AkShare → 计算一个指标 → 控制台输出阈值判定）。
   * 同时生成 `tests/` 的最小用例（契约/边界值）。
4. **确认后**，才允许进入 MDI#2（定时 + 落库）和 MDI#3（企业微信通知）。
5. 全程使用 **`make lint test run`** 的门禁命令，任何失败先修再继续。

---



# 一、开工前要准备好的（一次性/先行产出）

* **项目需求文档（PRD）**：项目简介、问题陈述、解决方案、目标用户、技术栈、核心功能、工作范围。作为“蓝图”供 AI 参考。 ([苏米客][1])
* **应用流程与功能说明（App Flow Doc）**：端到端流程，按页面/场景叙述，**建议避免使用项目符号**增强连贯性。 ([苏米客][1])
* **技术栈与依赖包清单**：前后端框架、库与版本（如 Next.js/Tailwind/shadcn、或 Python 技术栈等），优先选主流栈以匹配模型训练分布。 ([苏米客][1])
* **文件/目录结构（ASCII 树）**：提前给出结构，避免 AI 误建/误删文件、路径错位。 ([苏米客][1])
* **API 文档包**：将会用到的平台/API 的原始配置与示例（OpenAI/Claude/Supabase/Firebase…）集中粘贴到可引用文档。 ([苏米客][1])
* **后端架构设计（Schema Design）**：数据表/存储/鉴权等蓝图；如用 Supabase，可直接让 AI 产出可执行 SQL。 ([苏米客][1])
* **.cursorrules（或等价的 IDE 规则）**：告诉 AI 文档放哪、如何导航和遵循的项目级规则。 ([苏米客][1])
* **UI 布局与风格基线**：UI 包、字体、配色、图标、动效与一致性要求。 ([苏米客][1])
* **系统提示词（System Prompts）**：为 v0/bolt/Cursor 等准备项目专属 system 提示，减少重复上下文。 ([苏米客][1])

> 这些共同构成 Cursor 等 AI IDE 的“上下文边界”，能显著降低错误与幻觉、提升结构化产出与前后端集成效率。 ([苏米客][1])

---

# 二、可以在开发过程中逐步补齐的

* **细化/演进的 Schema 与 API**：根据迭代反馈补表、补索引、补接口；Supabase 场景下迭代 SQL 很方便。 ([苏米客][1])
* **前端页面与组件**：在已有 UI 基线下逐页推进、联调。 ([苏米客][1])
* **规则文件与提示词微调**：随着代码库成长，持续补充 .cursorrules、system prompts 的“导航与风格”。 ([苏米客][1])
* **文档充实**：把新增依赖、边界条件、错误码、数据契约等回填进统一文档集。 ([苏米客][1])

---

# 三、AI 编程步骤（落地流程）

1. 起草 **PRD** → 评审定稿。 ([苏米客][1])
2. 编写 **App Flow**（连续叙述，不用项目符号）并附关键页面草图。 ([苏米客][1])
3. 选定 **技术栈与依赖**（列版本&替代方案）。 ([苏米客][1])
4. 产出 **文件结构（ASCII 树）** 与命名规范。 ([苏米客][1])
5. 汇总 **API 文档** 与密钥配置方式（环境变量规范）。 ([苏米客][1])
6. 设计 **后端架构/Schema**，让 AI 生成初始化 SQL/存储策略；落库。 ([苏米客][1])
7. 编写 **.cursorrules**（或等价规则）作为 IDE 导航地图。 ([苏米客][1])
8. 制定 **UI 风格基线**（UI 包/字体/配色/图标/动效）。 ([苏米客][1])
9. 准备 **系统提示词**（按平台分组）。 ([苏米客][1])
10. 把上述文档喂给 Cursor/Claude 等 → 生成骨架代码 → 本地跑通。 ([苏米客][1])
11. **前后端联调**：按页面迭代实现与验收；持续充实文档与规则。 ([苏米客][1])
12. **质控与发布**：自测用例、错误码表、日志/监控与回滚策略；最终发布。
